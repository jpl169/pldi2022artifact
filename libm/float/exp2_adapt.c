#include <math.h>
#include "float_lib.h"
#include "exp2.h"

float rlibm_fast_exp2_adapt(float x) {
    float_x fx;
    fx.f = x;
    
    // Take care of special cases
    if (0x43000000 <= fx.x && fx.x <= 0xb338aa3b) {
        if (fx.x <= 0x7F800000) return 1.0/0.0;
        if (fx.x < 0x80000000) return 0.0/0.0;
        return 1.0;
    }
    
    if (fx.x <= 0x33b8aa3a) {
        return 1.0;
    }
    
    if (fx.x >= 0xc3160000) {
        if (fx.x <= 0xFF800000) return 0.0;
        return 0.0/0.0;
    }
    
    // Perform range reduction
    double xp = x * 64;
    int N = (int)xp;
    int N2 = N % 64;
    if (N2 < 0) N2 += 64;
    int N1 = N - N2;
    
    int M = N1 / 64;
    int J = N2;
    double R = x - N * 0.015625;

#if 0
    double y = 0.0;
    
    y = 1.3529558545669370488162552845778918708674609661102294921875000000000000e-03;
    y *= R;
    y += 9.6181130451127132274802278288916568271815776824951171875000000000000000e-03;
    y *= R;
    y += 5.5504104858622581308846832826020545326173305511474609375000000000000000e-02;
    y *= R;
    y += 2.4022650697767972127749658284301403909921646118164062500000000000000000e-01;
    y *= R;
    y += 6.9314718055997448509231162461219355463981628417968750000000000000000000e-01;
    y *= R;
    y += 9.9999999999999988897769753748434595763683319091796875000000000000000000e-01;
#else
    double k = R + 5.7090098393312249669406810426153242588043212890625000000000000000000000e-01;
    double z = k*k;
    double y = 0.0;

    y = (z + 2.8049551641867711992972544976510107517242431640625000000000000000000000e+01)*z;
    y += 3.4493885566997818159507005475461483001708984375000000000000000000000000e+02;
    y *= (R + 4.8253590157537145088895158551167696714401245117187500000000000000000000e+00);
    y += -9.6995806522104999203293118625879287719726562500000000000000000000000000e+02;
    y *= 1.3529558545669370488162552845778918708674609661102294921875000000000000e-03;
#endif

    // Perform output compensation
    return y * ldexp(exp2JBy64[J], M);
}
